{
  "version": 3,
  "sources": ["../echarts-wordcloud/src/WordCloudSeries.js", "../echarts-wordcloud/src/WordCloudView.js", "../echarts-wordcloud/src/layout.js", "../echarts-wordcloud/src/wordCloud.js"],
  "sourcesContent": ["import * as echarts from 'echarts/lib/echarts';\n\necharts.extendSeriesModel({\n\n    type: 'series.wordCloud',\n\n    visualStyleAccessPath: 'textStyle',\n    visualStyleMapper: function (model) {\n        return {\n            fill: model.get('color')\n        };\n    },\n    visualDrawType: 'fill',\n\n    optionUpdated: function () {\n        var option = this.option;\n        option.gridSize = Math.max(Math.floor(option.gridSize), 4);\n    },\n\n    getInitialData: function (option, ecModel) {\n        var dimensions = echarts.helper.createDimensions(option.data, {\n            coordDimensions: ['value']\n        });\n        var list = new echarts.List(dimensions, this);\n        list.initData(option.data);\n        return list;\n    },\n\n    // Most of options are from https://github.com/timdream/wordcloud2.js/blob/gh-pages/API.md\n    defaultOption: {\n\n        maskImage: null,\n\n        // Shape can be 'circle', 'cardioid', 'diamond', 'triangle-forward', 'triangle', 'pentagon', 'star'\n        shape: 'circle',\n\n        left: 'center',\n\n        top: 'center',\n\n        width: '70%',\n\n        height: '80%',\n\n        sizeRange: [12, 60],\n\n        rotationRange: [-90, 90],\n\n        rotationStep: 45,\n\n        gridSize: 8,\n\n        drawOutOfBound: false,\n\n        textStyle: {\n            fontWeight: 'normal'\n        }\n    }\n});\n", "import * as echarts from 'echarts/lib/echarts';\n\necharts.extendChartView({\n\n    type: 'wordCloud',\n\n    render: function (seriesModel, ecModel, api) {\n        var group = this.group;\n        group.removeAll();\n\n        var data = seriesModel.getData();\n\n        var gridSize = seriesModel.get('gridSize');\n\n        seriesModel.layoutInstance.ondraw = function (text, size, dataIdx, drawn) {\n            var itemModel = data.getItemModel(dataIdx);\n            var textStyleModel = itemModel.getModel('textStyle');\n\n            var textEl = new echarts.graphic.Text({\n                style: echarts.helper.createTextStyle(textStyleModel),\n                scaleX: 1 / drawn.info.mu,\n                scaleY: 1 / drawn.info.mu,\n                x: (drawn.gx + drawn.info.gw / 2) * gridSize,\n                y: (drawn.gy + drawn.info.gh / 2) * gridSize,\n                rotation: drawn.rot\n            });\n            textEl.setStyle({\n                x: drawn.info.fillTextOffsetX,\n                y: drawn.info.fillTextOffsetY + size * 0.5,\n                text: text,\n                verticalAlign: 'middle',\n                fill: data.getItemVisual(dataIdx, 'style').fill,\n                fontSize: size\n            });\n\n            group.add(textEl);\n\n            data.setItemGraphicEl(dataIdx, textEl);\n\n            textEl.ensureState('emphasis').style = echarts.helper.createTextStyle(itemModel.getModel(['emphasis', 'textStyle']), {\n                state: 'emphasis'\n            });\n            textEl.ensureState('blur').style = echarts.helper.createTextStyle(itemModel.getModel(['blur', 'textStyle']), {\n                state: 'blur'\n            });\n\n            echarts.helper.enableHoverEmphasis(\n                textEl,\n                itemModel.get(['emphasis', 'focus']),\n                itemModel.get(['emphasis', 'blurScope'])\n            );\n\n            textEl.stateTransition = {\n                duration: seriesModel.get('animation') ? seriesModel.get(['stateAnimation', 'duration']) : 0,\n                easing: seriesModel.get(['stateAnimation', 'easing'])\n            };\n            // TODO\n            textEl.__highDownDispatcher = true;\n        };\n\n        this._model = seriesModel;\n    },\n\n    remove: function () {\n        this.group.removeAll();\n\n        this._model.layoutInstance.dispose();\n    },\n\n    dispose: function () {\n        this._model.layoutInstance.dispose();\n    }\n});\n", "/*!\n * wordcloud2.js\n * http://timdream.org/wordcloud2.js/\n *\n * Copyright 2011 - 2013 Tim Chien\n * Released under the MIT license\n */\n\n'use strict';\n\n// setImmediate\nif (!window.setImmediate) {\n  window.setImmediate = (function setupSetImmediate() {\n    return window.msSetImmediate ||\n    window.webkitSetImmediate ||\n    window.mozSetImmediate ||\n    window.oSetImmediate ||\n    (function setupSetZeroTimeout() {\n      if (!window.postMessage || !window.addEventListener) {\n        return null;\n      }\n\n      var callbacks = [undefined];\n      var message = 'zero-timeout-message';\n\n      // Like setTimeout, but only takes a function argument.  There's\n      // no time argument (always zero) and no arguments (you have to\n      // use a closure).\n      var setZeroTimeout = function setZeroTimeout(callback) {\n        var id = callbacks.length;\n        callbacks.push(callback);\n        window.postMessage(message + id.toString(36), '*');\n\n        return id;\n      };\n\n      window.addEventListener('message', function setZeroTimeoutMessage(evt) {\n        // Skipping checking event source, retarded IE confused this window\n        // object with another in the presence of iframe\n        if (typeof evt.data !== 'string' ||\n            evt.data.substr(0, message.length) !== message/* ||\n            evt.source !== window */) {\n          return;\n        }\n\n        evt.stopImmediatePropagation();\n\n        var id = parseInt(evt.data.substr(message.length), 36);\n        if (!callbacks[id]) {\n          return;\n        }\n\n        callbacks[id]();\n        callbacks[id] = undefined;\n      }, true);\n\n      /* specify clearImmediate() here since we need the scope */\n      window.clearImmediate = function clearZeroTimeout(id) {\n        if (!callbacks[id]) {\n          return;\n        }\n\n        callbacks[id] = undefined;\n      };\n\n      return setZeroTimeout;\n    })() ||\n    // fallback\n    function setImmediateFallback(fn) {\n      window.setTimeout(fn, 0);\n    };\n  })();\n}\n\nif (!window.clearImmediate) {\n  window.clearImmediate = (function setupClearImmediate() {\n    return window.msClearImmediate ||\n    window.webkitClearImmediate ||\n    window.mozClearImmediate ||\n    window.oClearImmediate ||\n    // \"clearZeroTimeout\" is implement on the previous block ||\n    // fallback\n    function clearImmediateFallback(timer) {\n      window.clearTimeout(timer);\n    };\n  })();\n}\n\n  // Check if WordCloud can run on this browser\n  var isSupported = (function isSupported() {\n    var canvas = document.createElement('canvas');\n    if (!canvas || !canvas.getContext) {\n      return false;\n    }\n\n    var ctx = canvas.getContext('2d');\n    if (!ctx.getImageData) {\n      return false;\n    }\n    if (!ctx.fillText) {\n      return false;\n    }\n\n    if (!Array.prototype.some) {\n      return false;\n    }\n    if (!Array.prototype.push) {\n      return false;\n    }\n\n    return true;\n  }());\n\n  // Find out if the browser impose minium font size by\n  // drawing small texts on a canvas and measure it's width.\n  var minFontSize = (function getMinFontSize() {\n    if (!isSupported) {\n      return;\n    }\n\n    var ctx = document.createElement('canvas').getContext('2d');\n\n    // start from 20\n    var size = 20;\n\n    // two sizes to measure\n    var hanWidth, mWidth;\n\n    while (size) {\n      ctx.font = size.toString(10) + 'px sans-serif';\n      if ((ctx.measureText('\\uFF37').width === hanWidth) &&\n          (ctx.measureText('m').width) === mWidth) {\n        return (size + 1);\n      }\n\n      hanWidth = ctx.measureText('\\uFF37').width;\n      mWidth = ctx.measureText('m').width;\n\n      size--;\n    }\n\n    return 0;\n  })();\n\n  // Based on http://jsfromhell.com/array/shuffle\n  var shuffleArray = function shuffleArray(arr) {\n    for (var j, x, i = arr.length; i;\n      j = Math.floor(Math.random() * i),\n      x = arr[--i], arr[i] = arr[j],\n      arr[j] = x) {}\n    return arr;\n  };\n\n  var WordCloud = function WordCloud(elements, options) {\n    if (!isSupported) {\n      return;\n    }\n\n    if (!Array.isArray(elements)) {\n      elements = [elements];\n    }\n\n    elements.forEach(function(el, i) {\n      if (typeof el === 'string') {\n        elements[i] = document.getElementById(el);\n        if (!elements[i]) {\n          throw 'The element id specified is not found.';\n        }\n      } else if (!el.tagName && !el.appendChild) {\n        throw 'You must pass valid HTML elements, or ID of the element.';\n      }\n    });\n\n    /* Default values to be overwritten by options object */\n    var settings = {\n      list: [],\n      fontFamily: '\"Trebuchet MS\", \"Heiti TC\", \"\u5FAE\u8EDF\u6B63\u9ED1\u9AD4\", ' +\n                  '\"Arial Unicode MS\", \"Droid Fallback Sans\", sans-serif',\n      fontWeight: 'normal',\n      color: 'random-dark',\n      minSize: 0, // 0 to disable\n      weightFactor: 1,\n      clearCanvas: true,\n      backgroundColor: '#fff',  // opaque white = rgba(255, 255, 255, 1)\n\n      gridSize: 8,\n      drawOutOfBound: false,\n      origin: null,\n\n      drawMask: false,\n      maskColor: 'rgba(255,0,0,0.3)',\n      maskGapWidth: 0.3,\n\n      layoutAnimation: true,\n\n      wait: 0,\n      abortThreshold: 0, // disabled\n      abort: function noop() {},\n\n      minRotation: - Math.PI / 2,\n      maxRotation: Math.PI / 2,\n      rotationStep: 0.1,\n\n      shuffle: true,\n      rotateRatio: 0.1,\n\n      shape: 'circle',\n      ellipticity: 0.65,\n\n      classes: null,\n\n      hover: null,\n      click: null\n    };\n\n    if (options) {\n      for (var key in options) {\n        if (key in settings) {\n          settings[key] = options[key];\n        }\n      }\n    }\n\n    /* Convert weightFactor into a function */\n    if (typeof settings.weightFactor !== 'function') {\n      var factor = settings.weightFactor;\n      settings.weightFactor = function weightFactor(pt) {\n        return pt * factor; //in px\n      };\n    }\n\n    /* Convert shape into a function */\n    if (typeof settings.shape !== 'function') {\n      switch (settings.shape) {\n        case 'circle':\n        /* falls through */\n        default:\n          // 'circle' is the default and a shortcut in the code loop.\n          settings.shape = 'circle';\n          break;\n\n        case 'cardioid':\n          settings.shape = function shapeCardioid(theta) {\n            return 1 - Math.sin(theta);\n          };\n          break;\n\n        /*\n        To work out an X-gon, one has to calculate \"m\",\n        where 1/(cos(2*PI/X)+m*sin(2*PI/X)) = 1/(cos(0)+m*sin(0))\n        http://www.wolframalpha.com/input/?i=1%2F%28cos%282*PI%2FX%29%2Bm*sin%28\n        2*PI%2FX%29%29+%3D+1%2F%28cos%280%29%2Bm*sin%280%29%29\n        Copy the solution into polar equation r = 1/(cos(t') + m*sin(t'))\n        where t' equals to mod(t, 2PI/X);\n        */\n\n        case 'diamond':\n        case 'square':\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n          // %28t%2C+PI%2F2%29%29%2Bsin%28mod+%28t%2C+PI%2F2%29%29%29%2C+t+%3D\n          // +0+..+2*PI\n          settings.shape = function shapeSquare(theta) {\n            var thetaPrime = theta % (2 * Math.PI / 4);\n            return 1 / (Math.cos(thetaPrime) + Math.sin(thetaPrime));\n          };\n          break;\n\n        case 'triangle-forward':\n          // http://www.wolframalpha.com/input/?i=plot+r+%3D+1%2F%28cos%28mod+\n          // %28t%2C+2*PI%2F3%29%29%2Bsqrt%283%29sin%28mod+%28t%2C+2*PI%2F3%29\n          // %29%29%2C+t+%3D+0+..+2*PI\n          settings.shape = function shapeTriangle(theta) {\n            var thetaPrime = theta % (2 * Math.PI / 3);\n            return 1 / (Math.cos(thetaPrime) +\n                        Math.sqrt(3) * Math.sin(thetaPrime));\n          };\n          break;\n\n        case 'triangle':\n        case 'triangle-upright':\n          settings.shape = function shapeTriangle(theta) {\n            var thetaPrime = (theta + Math.PI * 3 / 2) % (2 * Math.PI / 3);\n            return 1 / (Math.cos(thetaPrime) +\n                        Math.sqrt(3) * Math.sin(thetaPrime));\n          };\n          break;\n\n        case 'pentagon':\n          settings.shape = function shapePentagon(theta) {\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 5);\n            return 1 / (Math.cos(thetaPrime) +\n                        0.726543 * Math.sin(thetaPrime));\n          };\n          break;\n\n        case 'star':\n          settings.shape = function shapeStar(theta) {\n            var thetaPrime = (theta + 0.955) % (2 * Math.PI / 10);\n            if ((theta + 0.955) % (2 * Math.PI / 5) - (2 * Math.PI / 10) >= 0) {\n              return 1 / (Math.cos((2 * Math.PI / 10) - thetaPrime) +\n                          3.07768 * Math.sin((2 * Math.PI / 10) - thetaPrime));\n            } else {\n              return 1 / (Math.cos(thetaPrime) +\n                          3.07768 * Math.sin(thetaPrime));\n            }\n          };\n          break;\n      }\n    }\n\n    /* Make sure gridSize is a whole number and is not smaller than 4px */\n    settings.gridSize = Math.max(Math.floor(settings.gridSize), 4);\n\n    /* shorthand */\n    var g = settings.gridSize;\n    var maskRectWidth = g - settings.maskGapWidth;\n\n    /* normalize rotation settings */\n    var rotationRange = Math.abs(settings.maxRotation - settings.minRotation);\n    var minRotation = Math.min(settings.maxRotation, settings.minRotation);\n    var rotationStep = settings.rotationStep;\n\n    /* information/object available to all functions, set when start() */\n    var grid, // 2d array containing filling information\n      ngx, ngy, // width and height of the grid\n      center, // position of the center of the cloud\n      maxRadius;\n\n    /* timestamp for measuring each putWord() action */\n    var escapeTime;\n\n    /* function for getting the color of the text */\n    var getTextColor;\n    function random_hsl_color(min, max) {\n      return 'hsl(' +\n        (Math.random() * 360).toFixed() + ',' +\n        (Math.random() * 30 + 70).toFixed() + '%,' +\n        (Math.random() * (max - min) + min).toFixed() + '%)';\n    }\n    switch (settings.color) {\n      case 'random-dark':\n        getTextColor = function getRandomDarkColor() {\n          return random_hsl_color(10, 50);\n        };\n        break;\n\n      case 'random-light':\n        getTextColor = function getRandomLightColor() {\n          return random_hsl_color(50, 90);\n        };\n        break;\n\n      default:\n        if (typeof settings.color === 'function') {\n          getTextColor = settings.color;\n        }\n        break;\n    }\n\n    /* function for getting the classes of the text */\n    var getTextClasses = null;\n    if (typeof settings.classes === 'function') {\n      getTextClasses = settings.classes;\n    }\n\n    /* Interactive */\n    var interactive = false;\n    var infoGrid = [];\n    var hovered;\n\n    var getInfoGridFromMouseTouchEvent =\n    function getInfoGridFromMouseTouchEvent(evt) {\n      var canvas = evt.currentTarget;\n      var rect = canvas.getBoundingClientRect();\n      var clientX;\n      var clientY;\n      /** Detect if touches are available */\n      if (evt.touches) {\n        clientX = evt.touches[0].clientX;\n        clientY = evt.touches[0].clientY;\n      } else {\n        clientX = evt.clientX;\n        clientY = evt.clientY;\n      }\n      var eventX = clientX - rect.left;\n      var eventY = clientY - rect.top;\n\n      var x = Math.floor(eventX * ((canvas.width / rect.width) || 1) / g);\n      var y = Math.floor(eventY * ((canvas.height / rect.height) || 1) / g);\n\n      return infoGrid[x][y];\n    };\n\n    var wordcloudhover = function wordcloudhover(evt) {\n      var info = getInfoGridFromMouseTouchEvent(evt);\n\n      if (hovered === info) {\n        return;\n      }\n\n      hovered = info;\n      if (!info) {\n        settings.hover(undefined, undefined, evt);\n\n        return;\n      }\n\n      settings.hover(info.item, info.dimension, evt);\n\n    };\n\n    var wordcloudclick = function wordcloudclick(evt) {\n      var info = getInfoGridFromMouseTouchEvent(evt);\n      if (!info) {\n        return;\n      }\n\n      settings.click(info.item, info.dimension, evt);\n      evt.preventDefault();\n    };\n\n    /* Get points on the grid for a given radius away from the center */\n    var pointsAtRadius = [];\n    var getPointsAtRadius = function getPointsAtRadius(radius) {\n      if (pointsAtRadius[radius]) {\n        return pointsAtRadius[radius];\n      }\n\n      // Look for these number of points on each radius\n      var T = radius * 8;\n\n      // Getting all the points at this radius\n      var t = T;\n      var points = [];\n\n      if (radius === 0) {\n        points.push([center[0], center[1], 0]);\n      }\n\n      while (t--) {\n        // distort the radius to put the cloud in shape\n        var rx = 1;\n        if (settings.shape !== 'circle') {\n          rx = settings.shape(t / T * 2 * Math.PI); // 0 to 1\n        }\n\n        // Push [x, y, t]; t is used solely for getTextColor()\n        points.push([\n          center[0] + radius * rx * Math.cos(-t / T * 2 * Math.PI),\n          center[1] + radius * rx * Math.sin(-t / T * 2 * Math.PI) *\n            settings.ellipticity,\n          t / T * 2 * Math.PI]);\n      }\n\n      pointsAtRadius[radius] = points;\n      return points;\n    };\n\n    /* Return true if we had spent too much time */\n    var exceedTime = function exceedTime() {\n      return ((settings.abortThreshold > 0) &&\n        ((new Date()).getTime() - escapeTime > settings.abortThreshold));\n    };\n\n    /* Get the deg of rotation according to settings, and luck. */\n    var getRotateDeg = function getRotateDeg() {\n      if (settings.rotateRatio === 0) {\n        return 0;\n      }\n\n      if (Math.random() > settings.rotateRatio) {\n        return 0;\n      }\n\n      if (rotationRange === 0) {\n        return minRotation;\n      }\n\n      return minRotation + Math.round(Math.random() * rotationRange / rotationStep) * rotationStep;\n    };\n\n    var getTextInfo = function getTextInfo(word, weight, rotateDeg) {\n      // calculate the acutal font size\n      // fontSize === 0 means weightFactor function wants the text skipped,\n      // and size < minSize means we cannot draw the text.\n      var debug = false;\n      var fontSize = settings.weightFactor(weight);\n      if (fontSize <= settings.minSize) {\n        return false;\n      }\n\n      // Scale factor here is to make sure fillText is not limited by\n      // the minium font size set by browser.\n      // It will always be 1 or 2n.\n      var mu = 1;\n      if (fontSize < minFontSize) {\n        mu = (function calculateScaleFactor() {\n          var mu = 2;\n          while (mu * fontSize < minFontSize) {\n            mu += 2;\n          }\n          return mu;\n        })();\n      }\n\n      var fcanvas = document.createElement('canvas');\n      var fctx = fcanvas.getContext('2d', { willReadFrequently: true });\n\n      fctx.font = settings.fontWeight + ' ' +\n        (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n\n      // Estimate the dimension of the text with measureText().\n      var fw = fctx.measureText(word).width / mu;\n      var fh = Math.max(fontSize * mu,\n                        fctx.measureText('m').width,\n                        fctx.measureText('\\uFF37').width) / mu;\n\n      // Create a boundary box that is larger than our estimates,\n      // so text don't get cut of (it sill might)\n      var boxWidth = fw + fh * 2;\n      var boxHeight = fh * 3;\n      var fgw = Math.ceil(boxWidth / g);\n      var fgh = Math.ceil(boxHeight / g);\n      boxWidth = fgw * g;\n      boxHeight = fgh * g;\n\n      // Calculate the proper offsets to make the text centered at\n      // the preferred position.\n\n      // This is simply half of the width.\n      var fillTextOffsetX = - fw / 2;\n      // Instead of moving the box to the exact middle of the preferred\n      // position, for Y-offset we move 0.4 instead, so Latin alphabets look\n      // vertical centered.\n      var fillTextOffsetY = - fh * 0.4;\n\n      // Calculate the actual dimension of the canvas, considering the rotation.\n      var cgh = Math.ceil((boxWidth * Math.abs(Math.sin(rotateDeg)) +\n                           boxHeight * Math.abs(Math.cos(rotateDeg))) / g);\n      var cgw = Math.ceil((boxWidth * Math.abs(Math.cos(rotateDeg)) +\n                           boxHeight * Math.abs(Math.sin(rotateDeg))) / g);\n      var width = cgw * g;\n      var height = cgh * g;\n\n      fcanvas.setAttribute('width', width);\n      fcanvas.setAttribute('height', height);\n\n      if (debug) {\n        // Attach fcanvas to the DOM\n        document.body.appendChild(fcanvas);\n        // Save it's state so that we could restore and draw the grid correctly.\n        fctx.save();\n      }\n\n      // Scale the canvas with |mu|.\n      fctx.scale(1 / mu, 1 / mu);\n      fctx.translate(width * mu / 2, height * mu / 2);\n      fctx.rotate(- rotateDeg);\n\n      // Once the width/height is set, ctx info will be reset.\n      // Set it again here.\n      fctx.font = settings.fontWeight + ' ' +\n        (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n\n      // Fill the text into the fcanvas.\n      // XXX: We cannot because textBaseline = 'top' here because\n      // Firefox and Chrome uses different default line-height for canvas.\n      // Please read https://bugzil.la/737852#c6.\n      // Here, we use textBaseline = 'middle' and draw the text at exactly\n      // 0.5 * fontSize lower.\n      fctx.fillStyle = '#000';\n      fctx.textBaseline = 'middle';\n      fctx.fillText(word, fillTextOffsetX * mu,\n                    (fillTextOffsetY + fontSize * 0.5) * mu);\n\n      // Get the pixels of the text\n      var imageData = fctx.getImageData(0, 0, width, height).data;\n\n      if (exceedTime()) {\n        return false;\n      }\n\n      if (debug) {\n        // Draw the box of the original estimation\n        fctx.strokeRect(fillTextOffsetX * mu,\n                        fillTextOffsetY, fw * mu, fh * mu);\n        fctx.restore();\n      }\n\n      // Read the pixels and save the information to the occupied array\n      var occupied = [];\n      var gx = cgw, gy, x, y;\n      var bounds = [cgh / 2, cgw / 2, cgh / 2, cgw / 2];\n      while (gx--) {\n        gy = cgh;\n        while (gy--) {\n          y = g;\n          singleGridLoop: {\n            while (y--) {\n              x = g;\n              while (x--) {\n                if (imageData[((gy * g + y) * width +\n                               (gx * g + x)) * 4 + 3]) {\n                  occupied.push([gx, gy]);\n\n                  if (gx < bounds[3]) {\n                    bounds[3] = gx;\n                  }\n                  if (gx > bounds[1]) {\n                    bounds[1] = gx;\n                  }\n                  if (gy < bounds[0]) {\n                    bounds[0] = gy;\n                  }\n                  if (gy > bounds[2]) {\n                    bounds[2] = gy;\n                  }\n\n                  if (debug) {\n                    fctx.fillStyle = 'rgba(255, 0, 0, 0.5)';\n                    fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n                  }\n                  break singleGridLoop;\n                }\n              }\n            }\n            if (debug) {\n              fctx.fillStyle = 'rgba(0, 0, 255, 0.5)';\n              fctx.fillRect(gx * g, gy * g, g - 0.5, g - 0.5);\n            }\n          }\n        }\n      }\n\n      if (debug) {\n        fctx.fillStyle = 'rgba(0, 255, 0, 0.5)';\n        fctx.fillRect(bounds[3] * g,\n                      bounds[0] * g,\n                      (bounds[1] - bounds[3] + 1) * g,\n                      (bounds[2] - bounds[0] + 1) * g);\n      }\n\n      // Return information needed to create the text on the real canvas\n      return {\n        mu: mu,\n        occupied: occupied,\n        bounds: bounds,\n        gw: cgw,\n        gh: cgh,\n        fillTextOffsetX: fillTextOffsetX,\n        fillTextOffsetY: fillTextOffsetY,\n        fillTextWidth: fw,\n        fillTextHeight: fh,\n        fontSize: fontSize\n      };\n    };\n\n    /* Determine if there is room available in the given dimension */\n    var canFitText = function canFitText(gx, gy, gw, gh, occupied) {\n      // Go through the occupied points,\n      // return false if the space is not available.\n      var i = occupied.length;\n      while (i--) {\n        var px = gx + occupied[i][0];\n        var py = gy + occupied[i][1];\n\n        if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n          if (!settings.drawOutOfBound) {\n            return false;\n          }\n          continue;\n        }\n\n        if (!grid[px][py]) {\n          return false;\n        }\n      }\n      return true;\n    };\n\n    /* Actually draw the text on the grid */\n    var drawText = function drawText(gx, gy, info, word, weight,\n                                     distance, theta, rotateDeg, attributes) {\n\n      var fontSize = info.fontSize;\n      var color;\n      if (getTextColor) {\n        color = getTextColor(word, weight, fontSize, distance, theta);\n      } else {\n        color = settings.color;\n      }\n\n      var classes;\n      if (getTextClasses) {\n        classes = getTextClasses(word, weight, fontSize, distance, theta);\n      } else {\n        classes = settings.classes;\n      }\n\n      var dimension;\n      var bounds = info.bounds;\n      dimension = {\n        x: (gx + bounds[3]) * g,\n        y: (gy + bounds[0]) * g,\n        w: (bounds[1] - bounds[3] + 1) * g,\n        h: (bounds[2] - bounds[0] + 1) * g\n      };\n\n      elements.forEach(function(el) {\n        if (el.getContext) {\n          var ctx = el.getContext('2d');\n          var mu = info.mu;\n\n          // Save the current state before messing it\n          ctx.save();\n          ctx.scale(1 / mu, 1 / mu);\n\n          ctx.font = settings.fontWeight + ' ' +\n                     (fontSize * mu).toString(10) + 'px ' + settings.fontFamily;\n          ctx.fillStyle = color;\n\n          // Translate the canvas position to the origin coordinate of where\n          // the text should be put.\n          ctx.translate((gx + info.gw / 2) * g * mu,\n                        (gy + info.gh / 2) * g * mu);\n\n          if (rotateDeg !== 0) {\n            ctx.rotate(- rotateDeg);\n          }\n\n          // Finally, fill the text.\n\n          // XXX: We cannot because textBaseline = 'top' here because\n          // Firefox and Chrome uses different default line-height for canvas.\n          // Please read https://bugzil.la/737852#c6.\n          // Here, we use textBaseline = 'middle' and draw the text at exactly\n          // 0.5 * fontSize lower.\n          ctx.textBaseline = 'middle';\n          ctx.fillText(word, info.fillTextOffsetX * mu,\n                             (info.fillTextOffsetY + fontSize * 0.5) * mu);\n\n          // The below box is always matches how <span>s are positioned\n          /* ctx.strokeRect(info.fillTextOffsetX, info.fillTextOffsetY,\n            info.fillTextWidth, info.fillTextHeight); */\n\n          // Restore the state.\n          ctx.restore();\n        } else {\n          // drawText on DIV element\n          var span = document.createElement('span');\n          var transformRule = '';\n          transformRule = 'rotate(' + (- rotateDeg / Math.PI * 180) + 'deg) ';\n          if (info.mu !== 1) {\n            transformRule +=\n              'translateX(-' + (info.fillTextWidth / 4) + 'px) ' +\n              'scale(' + (1 / info.mu) + ')';\n          }\n          var styleRules = {\n            'position': 'absolute',\n            'display': 'block',\n            'font': settings.fontWeight + ' ' +\n                    (fontSize * info.mu) + 'px ' + settings.fontFamily,\n            'left': ((gx + info.gw / 2) * g + info.fillTextOffsetX) + 'px',\n            'top': ((gy + info.gh / 2) * g + info.fillTextOffsetY) + 'px',\n            'width': info.fillTextWidth + 'px',\n            'height': info.fillTextHeight + 'px',\n            'lineHeight': fontSize + 'px',\n            'whiteSpace': 'nowrap',\n            'transform': transformRule,\n            'webkitTransform': transformRule,\n            'msTransform': transformRule,\n            'transformOrigin': '50% 40%',\n            'webkitTransformOrigin': '50% 40%',\n            'msTransformOrigin': '50% 40%'\n          };\n          if (color) {\n            styleRules.color = color;\n          }\n          span.textContent = word;\n          for (var cssProp in styleRules) {\n            span.style[cssProp] = styleRules[cssProp];\n          }\n          if (attributes) {\n            for (var attribute in attributes) {\n              span.setAttribute(attribute, attributes[attribute]);\n            }\n          }\n          if (classes) {\n            span.className += classes;\n          }\n          el.appendChild(span);\n        }\n      });\n    };\n\n    /* Help function to updateGrid */\n    var fillGridAt = function fillGridAt(x, y, drawMask, dimension, item) {\n      if (x >= ngx || y >= ngy || x < 0 || y < 0) {\n        return;\n      }\n\n      grid[x][y] = false;\n\n      if (drawMask) {\n        var ctx = elements[0].getContext('2d');\n        ctx.fillRect(x * g, y * g, maskRectWidth, maskRectWidth);\n      }\n\n      if (interactive) {\n        infoGrid[x][y] = { item: item, dimension: dimension };\n      }\n    };\n\n    /* Update the filling information of the given space with occupied points.\n       Draw the mask on the canvas if necessary. */\n    var updateGrid = function updateGrid(gx, gy, gw, gh, info, item) {\n      var occupied = info.occupied;\n      var drawMask = settings.drawMask;\n      var ctx;\n      if (drawMask) {\n        ctx = elements[0].getContext('2d');\n        ctx.save();\n        ctx.fillStyle = settings.maskColor;\n      }\n\n      var dimension;\n      if (interactive) {\n        var bounds = info.bounds;\n        dimension = {\n          x: (gx + bounds[3]) * g,\n          y: (gy + bounds[0]) * g,\n          w: (bounds[1] - bounds[3] + 1) * g,\n          h: (bounds[2] - bounds[0] + 1) * g\n        };\n      }\n\n      var i = occupied.length;\n      while (i--) {\n        var px = gx + occupied[i][0];\n        var py = gy + occupied[i][1];\n\n        if (px >= ngx || py >= ngy || px < 0 || py < 0) {\n          continue;\n        }\n\n        fillGridAt(px, py, drawMask, dimension, item);\n      }\n\n      if (drawMask) {\n        ctx.restore();\n      }\n    };\n\n    /* putWord() processes each item on the list,\n       calculate it's size and determine it's position, and actually\n       put it on the canvas. */\n    var putWord = function putWord(item) {\n      var word, weight, attributes;\n      if (Array.isArray(item)) {\n        word = item[0];\n        weight = item[1];\n      } else {\n        word = item.word;\n        weight = item.weight;\n        attributes = item.attributes;\n      }\n      var rotateDeg = getRotateDeg();\n\n      // get info needed to put the text onto the canvas\n      var info = getTextInfo(word, weight, rotateDeg);\n\n      // not getting the info means we shouldn't be drawing this one.\n      if (!info) {\n        return false;\n      }\n\n      if (exceedTime()) {\n        return false;\n      }\n\n      // If drawOutOfBound is set to false,\n      // skip the loop if we have already know the bounding box of\n      // word is larger than the canvas.\n      if (!settings.drawOutOfBound) {\n        var bounds = info.bounds;\n        if ((bounds[1] - bounds[3] + 1) > ngx ||\n          (bounds[2] - bounds[0] + 1) > ngy) {\n          return false;\n        }\n      }\n\n      // Determine the position to put the text by\n      // start looking for the nearest points\n      var r = maxRadius + 1;\n\n      var tryToPutWordAtPoint = function(gxy) {\n        var gx = Math.floor(gxy[0] - info.gw / 2);\n        var gy = Math.floor(gxy[1] - info.gh / 2);\n        var gw = info.gw;\n        var gh = info.gh;\n\n        // If we cannot fit the text at this position, return false\n        // and go to the next position.\n        if (!canFitText(gx, gy, gw, gh, info.occupied)) {\n          return false;\n        }\n\n        // Actually put the text on the canvas\n        drawText(gx, gy, info, word, weight,\n                 (maxRadius - r), gxy[2], rotateDeg, attributes);\n\n        // Mark the spaces on the grid as filled\n        updateGrid(gx, gy, gw, gh, info, item);\n\n        return {\n          gx: gx,\n          gy: gy,\n          rot: rotateDeg,\n          info: info\n        };\n      };\n\n      while (r--) {\n        var points = getPointsAtRadius(maxRadius - r);\n\n        if (settings.shuffle) {\n          points = [].concat(points);\n          shuffleArray(points);\n        }\n\n        // Try to fit the words by looking at each point.\n        // array.some() will stop and return true\n        // when putWordAtPoint() returns true.\n        for (var i = 0; i < points.length; i++) {\n          var res = tryToPutWordAtPoint(points[i]);\n          if (res) {\n            return res;\n          }\n        }\n\n        // var drawn = points.some(tryToPutWordAtPoint);\n        // if (drawn) {\n        //   // leave putWord() and return true\n        //   return true;\n        // }\n      }\n      // we tried all distances but text won't fit, return null\n      return null;\n    };\n\n    /* Send DOM event to all elements. Will stop sending event and return\n       if the previous one is canceled (for cancelable events). */\n    var sendEvent = function sendEvent(type, cancelable, detail) {\n      if (cancelable) {\n        return !elements.some(function(el) {\n          var evt = document.createEvent('CustomEvent');\n          evt.initCustomEvent(type, true, cancelable, detail || {});\n          return !el.dispatchEvent(evt);\n        }, this);\n      } else {\n        elements.forEach(function(el) {\n          var evt = document.createEvent('CustomEvent');\n          evt.initCustomEvent(type, true, cancelable, detail || {});\n          el.dispatchEvent(evt);\n        }, this);\n      }\n    };\n\n    /* Start drawing on a canvas */\n    var start = function start() {\n      // For dimensions, clearCanvas etc.,\n      // we only care about the first element.\n      var canvas = elements[0];\n\n      if (canvas.getContext) {\n        ngx = Math.ceil(canvas.width / g);\n        ngy = Math.ceil(canvas.height / g);\n      } else {\n        var rect = canvas.getBoundingClientRect();\n        ngx = Math.ceil(rect.width / g);\n        ngy = Math.ceil(rect.height / g);\n      }\n\n      // Sending a wordcloudstart event which cause the previous loop to stop.\n      // Do nothing if the event is canceled.\n      if (!sendEvent('wordcloudstart', true)) {\n        return;\n      }\n\n      // Determine the center of the word cloud\n      center = (settings.origin) ?\n        [settings.origin[0]/g, settings.origin[1]/g] :\n        [ngx / 2, ngy / 2];\n\n      // Maxium radius to look for space\n      maxRadius = Math.floor(Math.sqrt(ngx * ngx + ngy * ngy));\n\n      /* Clear the canvas only if the clearCanvas is set,\n         if not, update the grid to the current canvas state */\n      grid = [];\n\n      var gx, gy, i;\n      if (!canvas.getContext || settings.clearCanvas) {\n        elements.forEach(function(el) {\n          if (el.getContext) {\n            var ctx = el.getContext('2d');\n            ctx.fillStyle = settings.backgroundColor;\n            ctx.clearRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n            ctx.fillRect(0, 0, ngx * (g + 1), ngy * (g + 1));\n          } else {\n            el.textContent = '';\n            el.style.backgroundColor = settings.backgroundColor;\n            el.style.position = 'relative';\n          }\n        });\n\n        /* fill the grid with empty state */\n        gx = ngx;\n        while (gx--) {\n          grid[gx] = [];\n          gy = ngy;\n          while (gy--) {\n            grid[gx][gy] = true;\n          }\n        }\n      } else {\n        /* Determine bgPixel by creating\n           another canvas and fill the specified background color. */\n        var bctx = document.createElement('canvas').getContext('2d');\n\n        bctx.fillStyle = settings.backgroundColor;\n        bctx.fillRect(0, 0, 1, 1);\n        var bgPixel = bctx.getImageData(0, 0, 1, 1).data;\n\n        /* Read back the pixels of the canvas we got to tell which part of the\n           canvas is empty.\n           (no clearCanvas only works with a canvas, not divs) */\n        var imageData =\n          canvas.getContext('2d').getImageData(0, 0, ngx * g, ngy * g).data;\n\n        gx = ngx;\n        var x, y;\n        while (gx--) {\n          grid[gx] = [];\n          gy = ngy;\n          while (gy--) {\n            y = g;\n            singleGridLoop: while (y--) {\n              x = g;\n              while (x--) {\n                i = 4;\n                while (i--) {\n                  if (imageData[((gy * g + y) * ngx * g +\n                                 (gx * g + x)) * 4 + i] !== bgPixel[i]) {\n                    grid[gx][gy] = false;\n                    break singleGridLoop;\n                  }\n                }\n              }\n            }\n            if (grid[gx][gy] !== false) {\n              grid[gx][gy] = true;\n            }\n          }\n        }\n\n        imageData = bctx = bgPixel = undefined;\n      }\n\n      // fill the infoGrid with empty state if we need it\n      if (settings.hover || settings.click) {\n\n        interactive = true;\n\n        /* fill the grid with empty state */\n        gx = ngx + 1;\n        while (gx--) {\n          infoGrid[gx] = [];\n        }\n\n        if (settings.hover) {\n          canvas.addEventListener('mousemove', wordcloudhover);\n        }\n\n        if (settings.click) {\n          canvas.addEventListener('click', wordcloudclick);\n          canvas.addEventListener('touchstart', wordcloudclick);\n          canvas.addEventListener('touchend', function (e) {\n            e.preventDefault();\n          });\n          canvas.style.webkitTapHighlightColor = 'rgba(0, 0, 0, 0)';\n        }\n\n        canvas.addEventListener('wordcloudstart', function stopInteraction() {\n          canvas.removeEventListener('wordcloudstart', stopInteraction);\n\n          canvas.removeEventListener('mousemove', wordcloudhover);\n          canvas.removeEventListener('click', wordcloudclick);\n          hovered = undefined;\n        });\n      }\n\n      i = 0;\n      var loopingFunction, stoppingFunction;\n      var layouting = true;\n      if (!settings.layoutAnimation) {\n        loopingFunction = function (cb) {\n          cb();\n        }\n        stoppingFunction = function () {\n          layouting = false;\n        }\n      }\n      else if (settings.wait !== 0) {\n        loopingFunction = window.setTimeout;\n        stoppingFunction = window.clearTimeout;\n      } else {\n        loopingFunction = window.setImmediate;\n        stoppingFunction = window.clearImmediate;\n      }\n\n      var addEventListener = function addEventListener(type, listener) {\n        elements.forEach(function(el) {\n          el.addEventListener(type, listener);\n        }, this);\n      };\n\n      var removeEventListener = function removeEventListener(type, listener) {\n        elements.forEach(function(el) {\n          el.removeEventListener(type, listener);\n        }, this);\n      };\n\n      var anotherWordCloudStart = function anotherWordCloudStart() {\n        removeEventListener('wordcloudstart', anotherWordCloudStart);\n        stoppingFunction(timer);\n      };\n\n      addEventListener('wordcloudstart', anotherWordCloudStart);\n\n      // At least wait the following code before call the first iteration.\n      var timer = (settings.layoutAnimation ? loopingFunction : setTimeout)(function loop() {\n        if (!layouting) {\n          return;\n        }\n        if (i >= settings.list.length) {\n          stoppingFunction(timer);\n          sendEvent('wordcloudstop', false);\n          removeEventListener('wordcloudstart', anotherWordCloudStart);\n\n          return;\n        }\n        escapeTime = (new Date()).getTime();\n        var drawn = putWord(settings.list[i]);\n        var canceled = !sendEvent('wordclouddrawn', true, {\n          item: settings.list[i], drawn: drawn });\n        if (exceedTime() || canceled) {\n          stoppingFunction(timer);\n          settings.abort();\n          sendEvent('wordcloudabort', false);\n          sendEvent('wordcloudstop', false);\n          removeEventListener('wordcloudstart', anotherWordCloudStart);\n          return;\n        }\n        i++;\n        timer = loopingFunction(loop, settings.wait);\n      }, settings.wait);\n    };\n\n    // All set, start the drawing\n    start();\n  };\n\n  WordCloud.isSupported = isSupported;\n  WordCloud.minFontSize = minFontSize;\n\n  export default WordCloud;", "import * as echarts from 'echarts/lib/echarts';\n\nimport './WordCloudSeries';\nimport './WordCloudView';\n\nimport wordCloudLayoutHelper from './layout';\n\nif (!wordCloudLayoutHelper.isSupported) {\n    throw new Error('Sorry your browser not support wordCloud');\n}\n\n// https://github.com/timdream/wordcloud2.js/blob/c236bee60436e048949f9becc4f0f67bd832dc5c/index.js#L233\nfunction updateCanvasMask(maskCanvas) {\n    var ctx = maskCanvas.getContext('2d');\n    var imageData = ctx.getImageData(\n        0, 0, maskCanvas.width, maskCanvas.height);\n    var newImageData = ctx.createImageData(imageData);\n\n    var toneSum = 0;\n    var toneCnt = 0;\n    for (var i = 0; i < imageData.data.length; i += 4) {\n        var alpha = imageData.data[i + 3];\n        if (alpha > 128) {\n            var tone = imageData.data[i]\n                + imageData.data[i + 1]\n                + imageData.data[i + 2];\n            toneSum += tone;\n            ++toneCnt;\n        }\n    }\n    var threshold = toneSum / toneCnt;\n\n    for (var i = 0; i < imageData.data.length; i += 4) {\n        var tone = imageData.data[i]\n            + imageData.data[i + 1]\n            + imageData.data[i + 2];\n        var alpha = imageData.data[i + 3];\n\n        if (alpha < 128 || tone > threshold) {\n            // Area not to draw\n            newImageData.data[i] = 0;\n            newImageData.data[i + 1] = 0;\n            newImageData.data[i + 2] = 0;\n            newImageData.data[i + 3] = 0;\n        }\n        else {\n            // Area to draw\n            // The color must be same with backgroundColor\n            newImageData.data[i] = 255;\n            newImageData.data[i + 1] = 255;\n            newImageData.data[i + 2] = 255;\n            newImageData.data[i + 3] = 255;\n        }\n    }\n\n    ctx.putImageData(newImageData, 0, 0);\n}\n\necharts.registerLayout(function (ecModel, api) {\n    ecModel.eachSeriesByType('wordCloud', function (seriesModel) {\n        var gridRect = echarts.helper.getLayoutRect(\n            seriesModel.getBoxLayoutParams(), {\n                width: api.getWidth(),\n                height: api.getHeight()\n            }\n        );\n        var data = seriesModel.getData();\n\n        var canvas = document.createElement('canvas');\n        canvas.width = gridRect.width;\n        canvas.height = gridRect.height;\n\n        var ctx = canvas.getContext('2d');\n        var maskImage = seriesModel.get('maskImage');\n        if (maskImage) {\n            try {\n                ctx.drawImage(maskImage, 0, 0, canvas.width, canvas.height);\n                updateCanvasMask(canvas);\n            }\n            catch (e) {\n                console.error('Invalid mask image');\n                console.error(e.toString());\n            }\n        }\n\n        var sizeRange = seriesModel.get('sizeRange');\n        var rotationRange = seriesModel.get('rotationRange');\n        var valueExtent = data.getDataExtent('value');\n\n        var DEGREE_TO_RAD = Math.PI / 180;\n        var gridSize = seriesModel.get('gridSize');\n        wordCloudLayoutHelper(canvas, {\n            list: data.mapArray('value', function (value, idx) {\n                var itemModel = data.getItemModel(idx);\n                return [\n                    data.getName(idx),\n                    itemModel.get('textStyle.fontSize', true)\n                        || echarts.number.linearMap(value, valueExtent, sizeRange),\n                    idx\n                ];\n            }).sort(function (a, b) {\n                // Sort from large to small in case there is no more room for more words\n                return b[1] - a[1];\n            }),\n            fontFamily: seriesModel.get('textStyle.fontFamily')\n                || seriesModel.get('emphasis.textStyle.fontFamily')\n                || ecModel.get('textStyle.fontFamily'),\n            fontWeight: seriesModel.get('textStyle.fontWeight')\n                || seriesModel.get('emphasis.textStyle.fontWeight')\n                || ecModel.get('textStyle.fontWeight'),\n\n            gridSize: gridSize,\n\n            ellipticity: gridRect.height / gridRect.width,\n\n            minRotation: rotationRange[0] * DEGREE_TO_RAD,\n            maxRotation: rotationRange[1] * DEGREE_TO_RAD,\n\n            clearCanvas: !maskImage,\n\n            rotateRatio: 1,\n\n            rotationStep: seriesModel.get('rotationStep') * DEGREE_TO_RAD,\n\n            drawOutOfBound: seriesModel.get('drawOutOfBound'),\n\n            layoutAnimation: seriesModel.get('layoutAnimation'),\n\n            shuffle: false,\n\n            shape: seriesModel.get('shape')\n        });\n\n        function onWordCloudDrawn(e) {\n            var item = e.detail.item;\n            if (e.detail.drawn && seriesModel.layoutInstance.ondraw) {\n                e.detail.drawn.gx += gridRect.x / gridSize;\n                e.detail.drawn.gy += gridRect.y / gridSize;\n                seriesModel.layoutInstance.ondraw(\n                    item[0], item[1], item[2], e.detail.drawn\n                );\n            }\n        }\n\n        canvas.addEventListener('wordclouddrawn', onWordCloudDrawn);\n\n        if (seriesModel.layoutInstance) {\n            // Dispose previous\n            seriesModel.layoutInstance.dispose();\n        }\n\n        seriesModel.layoutInstance = {\n            ondraw: null,\n\n            dispose: function () {\n                canvas.removeEventListener('wordclouddrawn', onWordCloudDrawn);\n                // Abort\n                canvas.addEventListener('wordclouddrawn', function (e) {\n                    // Prevent default to cancle the event and stop the loop\n                    e.preventDefault();\n                });\n            }\n        };\n    });\n});\n\necharts.registerPreprocessor(function (option) {\n    var series = (option || {}).series;\n    !echarts.util.isArray(series) && (series = series ? [series] : []);\n\n    var compats = ['shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'];\n\n    echarts.util.each(series, function (seriesItem) {\n        if (seriesItem && seriesItem.type === 'wordCloud') {\n            var textStyle = seriesItem.textStyle || {};\n\n            compatTextStyle(textStyle.normal);\n            compatTextStyle(textStyle.emphasis);\n        }\n    });\n\n    function compatTextStyle(textStyle) {\n        textStyle && echarts.util.each(compats, function (key) {\n            if (textStyle.hasOwnProperty(key)) {\n                textStyle['text' + echarts.format.capitalFirst(key)] = textStyle[key];\n            }\n        });\n    }\n});\n"],
  "mappings": "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",
  "names": []
}
