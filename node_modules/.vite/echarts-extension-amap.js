import {
  echarts_exports
} from "./chunk-K5IHHPW7.js";
import "./chunk-YJVBTNL7.js";
import {
  Component_default,
  Component_default2,
  getInstanceByDom,
  graphic_exports2 as graphic_exports,
  matrix_exports,
  throttle,
  use,
  util_exports2 as util_exports,
  version
} from "./chunk-DOS4MWQS.js";
import "./chunk-4YJPEX7N.js";

// node_modules/echarts-extension-amap/dist/echarts-extension-amap.esm.js
var isV5 = version.split(".")[0] > 4;
var isAMap2X = function isAMap2X2() {
  return AMap.version >= 2;
};
function v2Equal(a, b) {
  return a && b && a[0] === b[0] && a[1] === b[1];
}
var logMap = {};
function logWarn(tag, msg, once) {
  var log = "[ECharts][Extension][AMap]".concat(tag ? " " + tag + ":" : "", " ").concat(msg);
  once && logMap[log] || console.warn(log);
  once && (logMap[log] = true);
}
function clearLogMap() {
  logMap = {};
}
function dataToCoordSize(dataSize, dataItem) {
  dataItem = dataItem || [0, 0];
  return util_exports.map([0, 1], function(dimIdx) {
    var val = dataItem[dimIdx];
    var halfSize = dataSize[dimIdx] / 2;
    var p1 = [];
    var p2 = [];
    p1[dimIdx] = val - halfSize;
    p2[dimIdx] = val + halfSize;
    p1[1 - dimIdx] = p2[1 - dimIdx] = dataItem[1 - dimIdx];
    return Math.abs(this.dataToPoint(p1)[dimIdx] - this.dataToPoint(p2)[dimIdx]);
  }, this);
}
var excludedOptions = [
  "echartsLayerZIndex",
  "echartsLayerInteractive",
  "renderOnMoving",
  "largeMode",
  "returnMapCameraState",
  "layers"
];
function AMapCoordSys(amap, api) {
  this._amap = amap;
  this._api = api;
  this._mapOffset = [0, 0];
}
var AMapCoordSysProto = AMapCoordSys.prototype;
AMapCoordSysProto.setZoom = function(zoom) {
  this._zoom = zoom;
};
AMapCoordSysProto.setCenter = function(center) {
  var lnglat = new AMap.LngLat(center[0], center[1]);
  this._center = this._amap.lngLatToContainer(lnglat);
};
AMapCoordSysProto.setMapOffset = function(mapOffset) {
  this._mapOffset = mapOffset;
};
AMapCoordSysProto.setAMap = function(amap) {
  this._amap = amap;
};
AMapCoordSysProto.getAMap = function() {
  return this._amap;
};
AMapCoordSysProto.dataToPoint = function(data) {
  var lnglat = new AMap.LngLat(data[0], data[1]);
  var px = this._amap.lngLatToContainer(lnglat);
  var mapOffset = this._mapOffset;
  return [px.x - mapOffset[0], px.y - mapOffset[1]];
};
AMapCoordSysProto.pointToData = function(pt) {
  var mapOffset = this._mapOffset;
  var lnglat = this._amap.containerToLngLat(new AMap.Pixel(pt[0] + mapOffset[0], pt[1] + mapOffset[1]));
  return [lnglat.lng, lnglat.lat];
};
AMapCoordSysProto.getViewRect = function() {
  var api = this._api;
  return new graphic_exports.BoundingRect(0, 0, api.getWidth(), api.getHeight());
};
AMapCoordSysProto.getRoamTransform = function() {
  return matrix_exports.create();
};
AMapCoordSysProto.prepareCustoms = function() {
  var rect = this.getViewRect();
  return {
    coordSys: {
      type: "amap",
      x: rect.x,
      y: rect.y,
      width: rect.width,
      height: rect.height
    },
    api: {
      coord: util_exports.bind(this.dataToPoint, this),
      size: util_exports.bind(dataToCoordSize, this)
    }
  };
};
AMapCoordSys.create = function(ecModel, api) {
  var amapCoordSys;
  ecModel.eachComponent("amap", function(amapModel) {
    if (typeof AMap === "undefined") {
      throw new Error("AMap api is not loaded");
    }
    if (amapCoordSys) {
      throw new Error("Only one amap component can exist");
    }
    var amap = amapModel.getAMap();
    var echartsLayerInteractive = amapModel.get("echartsLayerInteractive");
    if (!amap) {
      var root = api.getDom();
      var painter = api.getZr().painter;
      var viewportRoot = painter.getViewportRoot();
      viewportRoot.className = "amap-ec-layer";
      viewportRoot.style.visibility = "hidden";
      var amapRoot = root.querySelector(".ec-extension-amap");
      if (amapRoot) {
        viewportRoot.style.left = "0px";
        viewportRoot.style.top = "0px";
        root.removeChild(amapRoot);
      }
      amapRoot = document.createElement("div");
      amapRoot.className = "ec-extension-amap";
      amapRoot.style.cssText = "position:absolute;top:0;left:0;bottom:0;right:0;";
      root.appendChild(amapRoot);
      var options = util_exports.clone(amapModel.get());
      if ("echartsLayerZIndex" in options) {
        logWarn("DEPRECATED", "the option `echartsLayerZIndex` has been removed since v1.9.0, use `echartsLayerInteractive` instead.");
      }
      util_exports.each(excludedOptions, function(key) {
        delete options[key];
      });
      amap = new AMap.Map(amapRoot, options);
      amap.on("complete", function() {
        amapRoot.querySelector(".amap-maps").appendChild(viewportRoot);
        viewportRoot.style.visibility = "";
      });
      amapModel.setAMap(amap);
      amapModel.setEChartsLayer(viewportRoot);
      painter.getViewportRootOffset = function() {
        return {
          offsetLeft: 0,
          offsetTop: 0
        };
      };
    }
    var oldEChartsLayerInteractive = amapModel.__echartsLayerInteractive;
    if (oldEChartsLayerInteractive !== echartsLayerInteractive) {
      amapModel.setEChartsLayerInteractive(echartsLayerInteractive);
      amapModel.__echartsLayerInteractive = echartsLayerInteractive;
    }
    var center = amapModel.get("center");
    var zoom = amapModel.get("zoom");
    if (center && zoom) {
      var amapCenter = amap.getCenter();
      var amapZoom = amap.getZoom();
      var centerOrZoomChanged2 = amapModel.centerOrZoomChanged([amapCenter.lng, amapCenter.lat], amapZoom);
      if (centerOrZoomChanged2) {
        amap.setZoomAndCenter(zoom, new AMap.LngLat(center[0], center[1]));
      }
    }
    var originalMapStyle = amapModel.__mapStyle;
    var newMapStyle = amapModel.get("mapStyle");
    if (originalMapStyle !== newMapStyle) {
      amap.setMapStyle(amapModel.__mapStyle = newMapStyle);
    }
    if (amap.setLang) {
      var originalMapLang = amapModel.__mapLang;
      var newMapLang = amapModel.get("lang");
      if (originalMapLang !== newMapLang) {
        amap.setLang(amapModel.__mapLang = newMapLang);
      }
    } else {
      logWarn("CAVEAT", "The current map doesn't support `setLang` API!", true);
    }
    amapCoordSys = new AMapCoordSys(amap, api);
    amapCoordSys.setMapOffset(amapModel.__mapOffset || [0, 0]);
    amapCoordSys.setZoom(zoom);
    amapCoordSys.setCenter(center);
    amapModel.coordinateSystem = amapCoordSys;
  });
  ecModel.eachSeries(function(seriesModel) {
    if (seriesModel.get("coordinateSystem") === "amap") {
      seriesModel.coordinateSystem = amapCoordSys;
    }
  });
};
AMapCoordSysProto.dimensions = AMapCoordSys.dimensions = ["lng", "lat"];
var AMapModel = {
  type: "amap",
  setAMap: function setAMap(amap) {
    this.__amap = amap;
  },
  getAMap: function getAMap() {
    return this.__amap;
  },
  setEChartsLayer: function setEChartsLayer(layer) {
    this.__echartsLayer = layer;
  },
  getEChartsLayer: function getEChartsLayer() {
    return this.__echartsLayer;
  },
  setEChartsLayerVisiblity: function setEChartsLayerVisiblity(visible) {
    this.__echartsLayer.style.display = visible ? "block" : "none";
  },
  setEChartsLayerInteractive: function setEChartsLayerInteractive(interactive) {
    this.option.echartsLayerInteractive = !!interactive;
    this.__echartsLayer.style.pointerEvents = interactive ? "auto" : "none";
  },
  setCenterAndZoom: function setCenterAndZoom(center, zoom) {
    this.option.center = center;
    this.option.zoom = zoom;
  },
  centerOrZoomChanged: function centerOrZoomChanged(center, zoom) {
    var option = this.option;
    return !(v2Equal(center, option.center) && zoom === option.zoom);
  },
  defaultOption: {
    center: [116.397428, 39.90923],
    zoom: 5,
    isHotspot: false,
    resizeEnable: true,
    echartsLayerInteractive: true,
    renderOnMoving: true,
    largeMode: false,
    returnMapCameraState: false
  }
};
var AMapModel$1 = isV5 ? Component_default.extend(AMapModel) : AMapModel;
var _isAMap2X;
var AMapView = {
  type: "amap",
  init: function init() {
    this._isFirstRender = true;
    _isAMap2X = isAMap2X();
  },
  render: function render(amapModel, ecModel, api) {
    var rendering = true;
    var amap = amapModel.getAMap();
    var viewportRoot = api.getZr().painter.getViewportRoot();
    var offsetEl = amap.getContainer();
    var coordSys = amapModel.coordinateSystem;
    var renderOnMoving = amapModel.get("renderOnMoving");
    var resizeEnable = amapModel.get("resizeEnable");
    var largeMode = amapModel.get("largeMode");
    var returnMapCameraState = amapModel.get("returnMapCameraState");
    var viewMode = amap.getViewMode_();
    var is3DMode = viewMode === "3D";
    var moveHandler = function moveHandler2(e) {
      if (rendering) {
        return;
      }
      var offsetElStyle = offsetEl.style;
      var mapOffset = [-parseInt(offsetElStyle.left, 10) || 0, -parseInt(offsetElStyle.top, 10) || 0];
      var viewportRootStyle = viewportRoot.style;
      var offsetLeft = mapOffset[0] + "px";
      var offsetTop = mapOffset[1] + "px";
      if (viewportRootStyle.left !== offsetLeft) {
        viewportRootStyle.left = offsetLeft;
      }
      if (viewportRootStyle.top !== offsetTop) {
        viewportRootStyle.top = offsetTop;
      }
      coordSys.setMapOffset(amapModel.__mapOffset = mapOffset);
      var actionParams = {
        type: "amapRoam",
        animation: {
          duration: 0
        }
      };
      if (returnMapCameraState) {
        e = e || {};
        var center = e.center;
        if (!center) {
          center = amap.getCenter();
          center = [center.lng, center.lat];
        }
        actionParams.camera = {
          viewMode,
          center,
          zoom: e.zoom || amap.getZoom(),
          rotation: e.rotation == null ? amap.getRotation() : e.rotation,
          pitch: e.pitch == null ? amap.getPitch() : e.pitch,
          scale: amap.getScale(),
          bounds: amap.getBounds()
        };
      }
      api.dispatchAction(actionParams);
    };
    amap.off("mapmove", this._moveHandler);
    amap.off("moveend", this._moveHandler);
    amap.off("viewchange", this._moveHandler);
    amap.off("camerachange", this._moveHandler);
    amap.off("zoom", this._moveHandler);
    if (this._resizeHandler) {
      amap.off("resize", this._resizeHandler);
    }
    if (this._moveStartHandler) {
      amap.off("movestart", this._moveStartHandler);
    }
    if (this._moveEndHandler) {
      amap.off("moveend", this._moveEndHandler);
      amap.off("zoomend", this._moveEndHandler);
    }
    amap.on(renderOnMoving ? _isAMap2X ? "viewchange" : is3DMode ? "camerachange" : "mapmove" : "moveend", !_isAMap2X && largeMode ? moveHandler = throttle(moveHandler, 20, true) : moveHandler);
    this._moveHandler = moveHandler;
    if (renderOnMoving && !(_isAMap2X && is3DMode)) {
      amap.on("zoom", moveHandler);
    }
    if (!renderOnMoving) {
      amap.on("movestart", this._moveStartHandler = function() {
        setTimeout(function() {
          amapModel.setEChartsLayerVisiblity(false);
        }, 0);
      });
      var moveEndHandler = this._moveEndHandler = function(e) {
        (!e || e.type !== "moveend") && moveHandler(e);
        setTimeout(function() {
          amapModel.setEChartsLayerVisiblity(true);
        }, _isAMap2X || !largeMode ? 0 : 20);
      };
      amap.on("moveend", moveEndHandler);
      amap.on("zoomend", moveEndHandler);
      if (this._isFirstRender && is3DMode) {
        var nativeSetPicth = amap.setPitch;
        var nativeSetRotation = amap.setRotation;
        amap.setPitch = function() {
          nativeSetPicth.apply(this, arguments);
          moveEndHandler();
        };
        amap.setRotation = function() {
          nativeSetRotation.apply(this, arguments);
          moveEndHandler();
        };
      }
    }
    if (resizeEnable) {
      var resizeHandler = function resizeHandler2() {
        getInstanceByDom(api.getDom()).resize();
      };
      if (!_isAMap2X && largeMode) {
        resizeHandler = throttle(resizeHandler, 20, true);
      }
      amap.on("resize", this._resizeHandler = resizeHandler);
    }
    this._isFirstRender = rendering = false;
  },
  dispose: function dispose(ecModel) {
    clearLogMap();
    var component = ecModel.getComponent("amap");
    if (component) {
      component.getAMap().destroy();
      component.setAMap(null);
      component.setEChartsLayer(null);
      if (component.coordinateSystem) {
        component.coordinateSystem.setAMap(null);
        component.coordinateSystem = null;
      }
      delete this._moveHandler;
      delete this._resizeHandler;
      delete this._moveStartHandler;
      delete this._moveEndHandler;
    }
  }
};
var AMapView$1 = isV5 ? Component_default2.extend(AMapView) : AMapView;
var name = "echarts-extension-amap";
var version2 = "1.10.1";
function install(registers) {
  isV5 ? registers.registerComponentModel(AMapModel$1) : registers.extendComponentModel(AMapModel$1);
  isV5 ? registers.registerComponentView(AMapView$1) : registers.extendComponentView(AMapView$1);
  registers.registerCoordinateSystem("amap", AMapCoordSys);
  registers.registerAction({
    type: "amapRoam",
    event: "amapRoam",
    update: "updateLayout"
  }, function(payload, ecModel) {
    ecModel.eachComponent("amap", function(amapModel) {
      var amap = amapModel.getAMap();
      var center = amap.getCenter();
      amapModel.setCenterAndZoom([center.lng, center.lat], amap.getZoom());
    });
  });
}
isV5 ? use(install) : install(echarts_exports);
export {
  name,
  version2 as version
};
/*!
 * echarts-extension-amap 
 * @version 1.10.1
 * @author plainheart
 * 
 * MIT License
 * 
 * Copyright (c) 2019-2021 Zhongxiang.Wang
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 * 
 */
//# sourceMappingURL=echarts-extension-amap.js.map
